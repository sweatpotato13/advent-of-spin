// Generated by `wit-bindgen` 0.32.0. DO NOT EDIT!
// Options used:
//   * additional derives ["serde::Serialize", "serde::Deserialize", "Hash", "Clone", "PartialEq", "Eq"]
#[allow(dead_code)]
pub mod components {
  #[allow(dead_code)]
  pub mod advent_of_spin {
    #[allow(dead_code, clippy::all)]
    pub mod generator {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
      pub struct Suggestions {
        pub name: _rt::String,
        pub suggestions: _rt::String,
      }
      impl ::core::fmt::Debug for Suggestions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Suggestions").field("name", &self.name).field("suggestions", &self.suggestions).finish()
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn suggest(name: &str,age: u8,likes: &str,) -> Result<Suggestions,_rt::String>{
        unsafe {
          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 20]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 20]);
          let vec0 = name;
          let ptr0 = vec0.as_ptr().cast::<u8>();
          let len0 = vec0.len();
          let vec1 = likes;
          let ptr1 = vec1.as_ptr().cast::<u8>();
          let len1 = vec1.len();
          let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "components:advent-of-spin/generator@0.1.0")]
          extern "C" {
            #[link_name = "suggest"]
            fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ){ unreachable!() }
          wit_import(ptr0.cast_mut(), len0, _rt::as_i32(&age), ptr1.cast_mut(), len1, ptr2);
          let l3 = i32::from(*ptr2.add(0).cast::<u8>());
          match l3 {
            0 => {
              let e = {
                let l4 = *ptr2.add(4).cast::<*mut u8>();
                let l5 = *ptr2.add(8).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = *ptr2.add(12).cast::<*mut u8>();
                let l8 = *ptr2.add(16).cast::<usize>();
                let len9 = l8;
                let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                Suggestions{
                  name: _rt::string_lift(bytes6),
                  suggestions: _rt::string_lift(bytes9),
                }
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l10 = *ptr2.add(4).cast::<*mut u8>();
                let l11 = *ptr2.add(8).cast::<usize>();
                let len12 = l11;
                let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                _rt::string_lift(bytes12)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          }
        }
      }

    }

  }
}
#[allow(dead_code, clippy::all)]
pub mod exports {
  #[used]
  #[doc(hidden)]
  static __FORCE_SECTION_REF: fn() =
  super::__link_custom_section_describing_imports;
  
  use super::_rt;
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct Bundled {
    pub module: _rt::String,
    pub protocol: _rt::String,
    pub name: _rt::String,
  }
  impl ::core::fmt::Debug for Bundled {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("Bundled").field("module", &self.module).field("protocol", &self.protocol).field("name", &self.name).finish()
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct Function {
    pub protocol: _rt::String,
    pub name: _rt::String,
  }
  impl ::core::fmt::Debug for Function {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("Function").field("protocol", &self.protocol).field("name", &self.name).finish()
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct Constructor {
    pub module: _rt::String,
    pub protocol: _rt::String,
  }
  impl ::core::fmt::Debug for Constructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("Constructor").field("module", &self.module).field("protocol", &self.protocol).finish()
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct Static {
    pub module: _rt::String,
    pub protocol: _rt::String,
    pub name: _rt::String,
  }
  impl ::core::fmt::Debug for Static {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("Static").field("module", &self.module).field("protocol", &self.protocol).field("name", &self.name).finish()
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub enum FunctionExport {
    Bundled(Bundled),
    Freestanding(Function),
    Constructor(Constructor),
    Method(_rt::String),
    Static(Static),
  }
  impl ::core::fmt::Debug for FunctionExport {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      match self {
        FunctionExport::Bundled(e) => {
          f.debug_tuple("FunctionExport::Bundled").field(e).finish()
        }
        FunctionExport::Freestanding(e) => {
          f.debug_tuple("FunctionExport::Freestanding").field(e).finish()
        }
        FunctionExport::Constructor(e) => {
          f.debug_tuple("FunctionExport::Constructor").field(e).finish()
        }
        FunctionExport::Method(e) => {
          f.debug_tuple("FunctionExport::Method").field(e).finish()
        }
        FunctionExport::Static(e) => {
          f.debug_tuple("FunctionExport::Static").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct Case {
    pub name: _rt::String,
    pub has_payload: bool,
  }
  impl ::core::fmt::Debug for Case {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("Case").field("name", &self.name).field("has-payload", &self.has_payload).finish()
    }
  }
  #[repr(C)]
  #[derive(Clone, Copy, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct LocalResource {
    pub new: u32,
    pub rep: u32,
    pub drop: u32,
  }
  impl ::core::fmt::Debug for LocalResource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("LocalResource").field("new", &self.new).field("rep", &self.rep).field("drop", &self.drop).finish()
    }
  }
  #[repr(C)]
  #[derive(Clone, Copy, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct RemoteResource {
    pub drop: u32,
  }
  impl ::core::fmt::Debug for RemoteResource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("RemoteResource").field("drop", &self.drop).finish()
    }
  }
  #[repr(C)]
  #[derive(Clone, Copy, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct Resource {
    pub local: Option<LocalResource>,
    pub remote: Option<RemoteResource>,
  }
  impl ::core::fmt::Debug for Resource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("Resource").field("local", &self.local).field("remote", &self.remote).finish()
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub enum OwnedKind {
    Record(_rt::Vec::<_rt::String>),
    Variant(_rt::Vec::<Case>),
    Enum(u32),
    Flags(u32),
    Resource(Resource),
  }
  impl ::core::fmt::Debug for OwnedKind {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      match self {
        OwnedKind::Record(e) => {
          f.debug_tuple("OwnedKind::Record").field(e).finish()
        }
        OwnedKind::Variant(e) => {
          f.debug_tuple("OwnedKind::Variant").field(e).finish()
        }
        OwnedKind::Enum(e) => {
          f.debug_tuple("OwnedKind::Enum").field(e).finish()
        }
        OwnedKind::Flags(e) => {
          f.debug_tuple("OwnedKind::Flags").field(e).finish()
        }
        OwnedKind::Resource(e) => {
          f.debug_tuple("OwnedKind::Resource").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct OwnedType {
    pub kind: OwnedKind,
    pub package: _rt::String,
    pub name: _rt::String,
  }
  impl ::core::fmt::Debug for OwnedType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("OwnedType").field("kind", &self.kind).field("package", &self.package).field("name", &self.name).finish()
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub enum Type {
    Owned(OwnedType),
    Option,
    NestingOption,
    Result,
    Tuple(u32),
    Handle,
  }
  impl ::core::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      match self {
        Type::Owned(e) => {
          f.debug_tuple("Type::Owned").field(e).finish()
        }
        Type::Option => {
          f.debug_tuple("Type::Option").finish()
        }
        Type::NestingOption => {
          f.debug_tuple("Type::NestingOption").finish()
        }
        Type::Result => {
          f.debug_tuple("Type::Result").finish()
        }
        Type::Tuple(e) => {
          f.debug_tuple("Type::Tuple").field(e).finish()
        }
        Type::Handle => {
          f.debug_tuple("Type::Handle").finish()
        }
      }
    }
  }
  #[derive(Clone, Eq, Hash, PartialEq, serde::Deserialize, serde::Serialize)]
  pub struct Symbols {
    pub types_package: _rt::String,
    pub exports: _rt::Vec::<FunctionExport>,
    pub types: _rt::Vec::<Type>,
  }
  impl ::core::fmt::Debug for Symbols {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
      f.debug_struct("Symbols").field("types-package", &self.types_package).field("exports", &self.exports).field("types", &self.types).finish()
    }
  }
  #[allow(unused_unsafe, clippy::all)]
  pub fn init(app_name: &str,symbols: &Symbols,stub_wasi: bool,) -> Result<(),_rt::String>{
    unsafe {
      let mut cleanup_list = _rt::Vec::new();
      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 12]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
      let vec0 = app_name;
      let ptr0 = vec0.as_ptr().cast::<u8>();
      let len0 = vec0.len();
      let Symbols{ types_package:types_package1, exports:exports1, types:types1, } = symbols;
      let vec2 = types_package1;
      let ptr2 = vec2.as_ptr().cast::<u8>();
      let len2 = vec2.len();
      let vec18 = exports1;
      let len18 = vec18.len();
      let layout18 = _rt::alloc::Layout::from_size_align_unchecked(vec18.len() * 28, 4);
      let result18 = if layout18.size() != 0 {
        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
        if ptr.is_null()
        {
          _rt::alloc::handle_alloc_error(layout18);
        }
        ptr
      }else {
        ::core::ptr::null_mut()
      };
      for (i, e) in vec18.into_iter().enumerate() {
        let base = result18.add(i * 28);
        {
          match e {
            FunctionExport::Bundled(e) => {
              *base.add(0).cast::<u8>() = (0i32) as u8;
              let Bundled{ module:module3, protocol:protocol3, name:name3, } = e;
              let vec4 = module3;
              let ptr4 = vec4.as_ptr().cast::<u8>();
              let len4 = vec4.len();
              *base.add(8).cast::<usize>() = len4;
              *base.add(4).cast::<*mut u8>() = ptr4.cast_mut();
              let vec5 = protocol3;
              let ptr5 = vec5.as_ptr().cast::<u8>();
              let len5 = vec5.len();
              *base.add(16).cast::<usize>() = len5;
              *base.add(12).cast::<*mut u8>() = ptr5.cast_mut();
              let vec6 = name3;
              let ptr6 = vec6.as_ptr().cast::<u8>();
              let len6 = vec6.len();
              *base.add(24).cast::<usize>() = len6;
              *base.add(20).cast::<*mut u8>() = ptr6.cast_mut();
            },
            FunctionExport::Freestanding(e) => {
              *base.add(0).cast::<u8>() = (1i32) as u8;
              let Function{ protocol:protocol7, name:name7, } = e;
              let vec8 = protocol7;
              let ptr8 = vec8.as_ptr().cast::<u8>();
              let len8 = vec8.len();
              *base.add(8).cast::<usize>() = len8;
              *base.add(4).cast::<*mut u8>() = ptr8.cast_mut();
              let vec9 = name7;
              let ptr9 = vec9.as_ptr().cast::<u8>();
              let len9 = vec9.len();
              *base.add(16).cast::<usize>() = len9;
              *base.add(12).cast::<*mut u8>() = ptr9.cast_mut();
            },
            FunctionExport::Constructor(e) => {
              *base.add(0).cast::<u8>() = (2i32) as u8;
              let Constructor{ module:module10, protocol:protocol10, } = e;
              let vec11 = module10;
              let ptr11 = vec11.as_ptr().cast::<u8>();
              let len11 = vec11.len();
              *base.add(8).cast::<usize>() = len11;
              *base.add(4).cast::<*mut u8>() = ptr11.cast_mut();
              let vec12 = protocol10;
              let ptr12 = vec12.as_ptr().cast::<u8>();
              let len12 = vec12.len();
              *base.add(16).cast::<usize>() = len12;
              *base.add(12).cast::<*mut u8>() = ptr12.cast_mut();
            },
            FunctionExport::Method(e) => {
              *base.add(0).cast::<u8>() = (3i32) as u8;
              let vec13 = e;
              let ptr13 = vec13.as_ptr().cast::<u8>();
              let len13 = vec13.len();
              *base.add(8).cast::<usize>() = len13;
              *base.add(4).cast::<*mut u8>() = ptr13.cast_mut();
            },
            FunctionExport::Static(e) => {
              *base.add(0).cast::<u8>() = (4i32) as u8;
              let Static{ module:module14, protocol:protocol14, name:name14, } = e;
              let vec15 = module14;
              let ptr15 = vec15.as_ptr().cast::<u8>();
              let len15 = vec15.len();
              *base.add(8).cast::<usize>() = len15;
              *base.add(4).cast::<*mut u8>() = ptr15.cast_mut();
              let vec16 = protocol14;
              let ptr16 = vec16.as_ptr().cast::<u8>();
              let len16 = vec16.len();
              *base.add(16).cast::<usize>() = len16;
              *base.add(12).cast::<*mut u8>() = ptr16.cast_mut();
              let vec17 = name14;
              let ptr17 = vec17.as_ptr().cast::<u8>();
              let len17 = vec17.len();
              *base.add(24).cast::<usize>() = len17;
              *base.add(20).cast::<*mut u8>() = ptr17.cast_mut();
            },
          }
        }
      }
      let vec30 = types1;
      let len30 = vec30.len();
      let layout30 = _rt::alloc::Layout::from_size_align_unchecked(vec30.len() * 48, 4);
      let result30 = if layout30.size() != 0 {
        let ptr = _rt::alloc::alloc(layout30).cast::<u8>();
        if ptr.is_null()
        {
          _rt::alloc::handle_alloc_error(layout30);
        }
        ptr
      }else {
        ::core::ptr::null_mut()
      };
      for (i, e) in vec30.into_iter().enumerate() {
        let base = result30.add(i * 48);
        {
          match e {
            Type::Owned(e) => {
              *base.add(0).cast::<u8>() = (0i32) as u8;
              let OwnedType{ kind:kind19, package:package19, name:name19, } = e;
              match kind19 {
                OwnedKind::Record(e) => {
                  *base.add(4).cast::<u8>() = (0i32) as u8;
                  let vec21 = e;
                  let len21 = vec21.len();
                  let layout21 = _rt::alloc::Layout::from_size_align_unchecked(vec21.len() * 8, 4);
                  let result21 = if layout21.size() != 0 {
                    let ptr = _rt::alloc::alloc(layout21).cast::<u8>();
                    if ptr.is_null()
                    {
                      _rt::alloc::handle_alloc_error(layout21);
                    }
                    ptr
                  }else {
                    ::core::ptr::null_mut()
                  };
                  for (i, e) in vec21.into_iter().enumerate() {
                    let base = result21.add(i * 8);
                    {
                      let vec20 = e;
                      let ptr20 = vec20.as_ptr().cast::<u8>();
                      let len20 = vec20.len();
                      *base.add(4).cast::<usize>() = len20;
                      *base.add(0).cast::<*mut u8>() = ptr20.cast_mut();
                    }
                  }
                  *base.add(12).cast::<usize>() = len21;
                  *base.add(8).cast::<*mut u8>() = result21;
                  cleanup_list.extend_from_slice(&[(result21, layout21),]);
                },
                OwnedKind::Variant(e) => {
                  *base.add(4).cast::<u8>() = (1i32) as u8;
                  let vec24 = e;
                  let len24 = vec24.len();
                  let layout24 = _rt::alloc::Layout::from_size_align_unchecked(vec24.len() * 12, 4);
                  let result24 = if layout24.size() != 0 {
                    let ptr = _rt::alloc::alloc(layout24).cast::<u8>();
                    if ptr.is_null()
                    {
                      _rt::alloc::handle_alloc_error(layout24);
                    }
                    ptr
                  }else {
                    ::core::ptr::null_mut()
                  };
                  for (i, e) in vec24.into_iter().enumerate() {
                    let base = result24.add(i * 12);
                    {
                      let Case{ name:name22, has_payload:has_payload22, } = e;
                      let vec23 = name22;
                      let ptr23 = vec23.as_ptr().cast::<u8>();
                      let len23 = vec23.len();
                      *base.add(4).cast::<usize>() = len23;
                      *base.add(0).cast::<*mut u8>() = ptr23.cast_mut();
                      *base.add(8).cast::<u8>() = (match has_payload22 { true => 1, false => 0 }) as u8;
                    }
                  }
                  *base.add(12).cast::<usize>() = len24;
                  *base.add(8).cast::<*mut u8>() = result24;
                  cleanup_list.extend_from_slice(&[(result24, layout24),]);
                },
                OwnedKind::Enum(e) => {
                  *base.add(4).cast::<u8>() = (2i32) as u8;
                  *base.add(8).cast::<i32>() = _rt::as_i32(e);
                },
                OwnedKind::Flags(e) => {
                  *base.add(4).cast::<u8>() = (3i32) as u8;
                  *base.add(8).cast::<i32>() = _rt::as_i32(e);
                },
                OwnedKind::Resource(e) => {
                  *base.add(4).cast::<u8>() = (4i32) as u8;
                  let Resource{ local:local25, remote:remote25, } = e;
                  match local25 {
                    Some(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      let LocalResource{ new:new26, rep:rep26, drop:drop26, } = e;
                      *base.add(12).cast::<i32>() = _rt::as_i32(new26);
                      *base.add(16).cast::<i32>() = _rt::as_i32(rep26);
                      *base.add(20).cast::<i32>() = _rt::as_i32(drop26);
                    },
                    None => {
                      {
                        *base.add(8).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };match remote25 {
                    Some(e) => {
                      *base.add(24).cast::<u8>() = (1i32) as u8;
                      let RemoteResource{ drop:drop27, } = e;
                      *base.add(28).cast::<i32>() = _rt::as_i32(drop27);
                    },
                    None => {
                      {
                        *base.add(24).cast::<u8>() = (0i32) as u8;
                      }
                    },
                  };},
                }
                let vec28 = package19;
                let ptr28 = vec28.as_ptr().cast::<u8>();
                let len28 = vec28.len();
                *base.add(36).cast::<usize>() = len28;
                *base.add(32).cast::<*mut u8>() = ptr28.cast_mut();
                let vec29 = name19;
                let ptr29 = vec29.as_ptr().cast::<u8>();
                let len29 = vec29.len();
                *base.add(44).cast::<usize>() = len29;
                *base.add(40).cast::<*mut u8>() = ptr29.cast_mut();
              },
              Type::Option=> {
                {
                  *base.add(0).cast::<u8>() = (1i32) as u8;
                }
              }
              Type::NestingOption=> {
                {
                  *base.add(0).cast::<u8>() = (2i32) as u8;
                }
              }
              Type::Result=> {
                {
                  *base.add(0).cast::<u8>() = (3i32) as u8;
                }
              }
              Type::Tuple(e) => {
                *base.add(0).cast::<u8>() = (4i32) as u8;
                *base.add(4).cast::<i32>() = _rt::as_i32(e);
              },
              Type::Handle=> {
                {
                  *base.add(0).cast::<u8>() = (5i32) as u8;
                }
              }
            }
          }
        }
        let ptr31 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "exports")]
        extern "C" {
          #[link_name = "init"]
          fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, );
        }

        #[cfg(not(target_arch = "wasm32"))]
        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8, _: usize, _: i32, _: *mut u8, ){ unreachable!() }
        wit_import(ptr0.cast_mut(), len0, ptr2.cast_mut(), len2, result18, len18, result30, len30, match &stub_wasi { true => 1, false => 0 }, ptr31);
        let l32 = i32::from(*ptr31.add(0).cast::<u8>());
        if layout18.size() != 0 {
          _rt::alloc::dealloc(result18.cast(), layout18);
        }
        if layout30.size() != 0 {
          _rt::alloc::dealloc(result30.cast(), layout30);
        }
        for (ptr, layout) in cleanup_list {

          if layout.size() != 0 {

            _rt::alloc::dealloc(ptr.cast(), layout);

          }

        }
        match l32 {
          0 => {
            let e = ();
            Ok(e)
          }
          1 => {
            let e = {
              let l33 = *ptr31.add(4).cast::<*mut u8>();
              let l34 = *ptr31.add(8).cast::<usize>();
              let len35 = l34;
              let bytes35 = _rt::Vec::from_raw_parts(l33.cast(), len35, len35);

              _rt::string_lift(bytes35)
            };
            Err(e)
          }
          _ => _rt::invalid_enum_discriminant(),
        }
      }
    }

  }

  mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub use alloc_crate::alloc;

    pub fn as_i32<T: AsI32>(t: T) -> i32 {
      t.as_i32()
    }

    pub trait AsI32 {
      fn as_i32(self) -> i32;
    }

    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
      fn as_i32(self) -> i32 {
        (*self).as_i32()
      }
    }
    
    impl AsI32 for i32 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for u32 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for i16 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for u16 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for i8 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for u8 {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for char {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    
    impl AsI32 for usize {
      #[inline]
      fn as_i32(self) -> i32 {
        self as i32
      }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
      if cfg!(debug_assertions) {
        String::from_utf8(bytes).unwrap()
      } else {
        String::from_utf8_unchecked(bytes)
      }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
      if cfg!(debug_assertions) {
        panic!("invalid enum discriminant")
      } else {
        core::hint::unreachable_unchecked()
      }
    }
    extern crate alloc as alloc_crate;
  }

  #[cfg(target_arch = "wasm32")]
  #[link_section = "component-type:wit-bindgen:0.32.0:spin-deps:deps@0.1.0:deps:encoded world"]
  #[doc(hidden)]
  pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 970] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xcf\x06\x01A\x02\x01\
A\x04\x01B#\x01r\x03\x06modules\x08protocols\x04names\x04\0\x07bundled\x03\0\0\x01\
r\x02\x08protocols\x04names\x04\0\x08function\x03\0\x02\x01r\x02\x06modules\x08p\
rotocols\x04\0\x0bconstructor\x03\0\x04\x01r\x03\x06modules\x08protocols\x04name\
s\x04\0\x06static\x03\0\x06\x01q\x05\x07bundled\x01\x01\0\x0cfreestanding\x01\x03\
\0\x0bconstructor\x01\x05\0\x06method\x01s\0\x06static\x01\x07\0\x04\0\x0ffuncti\
on-export\x03\0\x08\x01r\x02\x04names\x0bhas-payload\x7f\x04\0\x04case\x03\0\x0a\
\x01r\x03\x03newy\x03repy\x04dropy\x04\0\x0elocal-resource\x03\0\x0c\x01r\x01\x04\
dropy\x04\0\x0fremote-resource\x03\0\x0e\x01k\x0d\x01k\x0f\x01r\x02\x05local\x10\
\x06remote\x11\x04\0\x08resource\x03\0\x12\x01ps\x01p\x0b\x01q\x05\x06record\x01\
\x14\0\x07variant\x01\x15\0\x04enum\x01y\0\x05flags\x01y\0\x08resource\x01\x13\0\
\x04\0\x0aowned-kind\x03\0\x16\x01r\x03\x04kind\x17\x07packages\x04names\x04\0\x0a\
owned-type\x03\0\x18\x01q\x06\x05owned\x01\x19\0\x06option\0\0\x0enesting-option\
\0\0\x06result\0\0\x05tuple\x01y\0\x06handle\0\0\x04\0\x04type\x03\0\x1a\x01p\x09\
\x01p\x1b\x01r\x03\x0dtypes-packages\x07exports\x1c\x05types\x1d\x04\0\x07symbol\
s\x03\0\x1e\x01j\0\x01s\x01@\x03\x08app-names\x07symbols\x1f\x09stub-wasi\x7f\0\x20\
\x04\0\x04init\x01!\x03\0\x07exports\x05\0\x01B\x05\x01r\x02\x04names\x0bsuggest\
ionss\x04\0\x0bsuggestions\x03\0\0\x01j\x01\x01\x01s\x01@\x03\x04names\x03age}\x05\
likess\0\x02\x04\0\x07suggest\x01\x03\x03\0)components:advent-of-spin/generator@\
0.1.0\x05\x01\x04\0\x19spin-deps:deps/deps@0.1.0\x04\0\x0b\x0a\x01\0\x04deps\x03\
\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.217.0\x10wit-\
bindgen-rust\x060.32.0";

  #[inline(never)]
  #[doc(hidden)]
  pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
  }
  
